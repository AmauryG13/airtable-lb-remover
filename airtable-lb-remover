#!/bin/bash
''':'
dir=${0%/*}
if [ -d "$dir" ]; then
  cd "$dir"
fi

printf "\n\n----------     Suppresion de saut de ligne | Fichier CSV Airtable     ----------"
printf "Dossier de travail actuel:\n$dir\n"

exec python "$0" "$@"
'''

import csv
import os
import logging

logging.basicConfig(
    format='LB Remover - %(levelname)s: [%(funcName)s]\n%(message)s \n',
    level=logging.WARNING
)

def fileReader(filename):
    with open(filename, "r") as f:
        return f.read()

class LBRemover(object):
    lbchar = '\n'

    def __init__(self, id, data):
        self.filename = {"id": id, "data": data}
        logging.info("Fichier avec les 'ids': {}".format(self.filename["id"]))
        logging.info("Fichier avec les 'data': {}".format(self.filename["data"]))

        self.ids = []

        if os.path.isfile(self.filename["id"]):
            with open(self.filename["id"]) as csvFile:
                reader = csv.reader(csvFile, delimiter=",")
                for row in reader:
                    if unicode(row[0], 'utf-8').isnumeric():
                        self.ids.append(row[0])
        else:
            if self.filename["id"].find(':') == -1:
                self.ids = self.filename["id"]
            else:
                numbers = self.filename["id"].split(':')
                self.ids = range(numbers[0], numbers[1], 1)

        self.content = fileReader(self.filename["data"])

        logging.debug('Ids: {}'.format(self.ids))
        logging.debug('Contenu: {}'.format(self.content))

    def _detectIndex(self, content, ids):
        index = []

        for idx, id in enumerate(ids):
            str = self.lbchar + id

            try:
                start = index[idx-1]
            except:
                start = 0

            index.insert(idx, content.find(str, start)+1)

        #index.sort()
        logging.debug('Index: {}'.format(index))
        return index

    def _createCSVLines(self, content, index):
        index.insert(0, 0)
        lines = [content[start:end]
                for start, end in zip(index, index[1:]+ [len(self.content)])]

        with open('lines.txt', 'w+') as file:
            for line in lines:
                file.write(line)
                file.write('\n\n --------------------------------------  \n\n')

        return lines;

    def _parseLines(self, content):
        occurence = 0
        lines = []

        for line in content:
            l = line[:-1]
            if l.find(self.lbchar) != -1:
                occurence += l.count(self.lbchar)
                lines.append(l.replace(self.lbchar, ''))
            else:
                lines.append(l)

        return [lines, occurence]

    def _writeNewCSVFile(self, content, filename=None):
        if filename is None:
            name, ext = os.path.splitext(self.filename["data"])
            filename = name + '_parsed' + ext

        with open(filename, 'w+') as file:
            for line in content:
                file.write(line + self.lbchar)

        print("Fichier '{}' ecrit".format(filename))

    def run(self, filename=None):
        lbcount = self.content.count(self.lbchar)
        logging.info('Nombre de SdL: {}'.format(lbcount))

        self.index = self._detectIndex(self.content, self.ids)
        logging.debug("Nombres d'index: {}".format(len(self.index)))

        self.lines = self._createCSVLines(self.content, self.index)
        logging.debug('Nombre de lignes : {}'.format(len(self.lines)))

        if len(self.lines) != len(self.ids)+1:
            logging.warning(
                "Plus de lignes ({0}) que d'identifiants ({1}): une erreur a pu survenir"
                .format(len(self.lines), len(self.ids))
            )

        [self.parsed, removed] = self._parseLines(self.lines)
        logging.debug('Nombre de lignes analysees: {0}'.format(len(self.parsed)))
        logging.info('SdL retires: {}'.format(removed))

        flbcount = lbcount - removed
        logging.info('Nombre de SdL final: {}'.format(flbcount))

        if flbcount+1 != len(self.lines):
            logging.warning(
                'Nombre de saut de lignes ({}) est different du nombre de lignes({}) : une erreur a pu survenir'
                .format(flbcount, len(self.lines))
            )

        self._writeNewCSVFile(self.parsed, filename)


if __name__ == '__main__':
    import sys
    import argparse

    parser = argparse.ArgumentParser(
                prog="Remover",
                usage="Remover [-h] [-d filename.csv] [-i filename.csv] [-o output.csv] [-v]",
                description="Script pour retirer les sauts de lignes dans un fichier CSV",
                epilog="LB Remover - Airtable | Amaury GUILLERMIN"
    )

    parser.add_argument("-d", "--data",
        metavar="",
        default="data.csv",
        help="Chemin jusqu'au fichier CSV de donnees"
    )

    parser.add_argument("-i", "--identifiants",
        metavar="",
        default="ids.csv",
        help="Chemin jusqu'au fichier CSV d'identifiants de projet"
    )

    parser.add_argument("-o", "--output",
        metavar="",
        default=None,
        help="Nom du fichier de sortie"
    )

    #parser.add_argument('-v', '--verbose', action='count', default=0)

    args = parser.parse_args()

    if len(sys.argv) <= 1:
        if args.identifiants == 'ids.csv':
            ids = raw_input("\nChemin vers le fichier des identifiants : \n")
            if not ids:
                ids = args.identifiants

        if args.data == 'data.csv':
            data = raw_input("\nChemin vers le fichier de donnees : \n")
            if not data:
                data = args.data
    else:
        ids = args.identifiants
        data = args.data

    print('\n')

    remover = LBRemover(ids, data)
    remover.run(args.output)
